import * as core from "@actions/core";
import * as github from "@actions/github";
import { CoverageAnalysis } from "./coverageAnalyzer";
import { LcovReport } from "./lcov";
import { GatingResult } from "./coverageGating";

export interface PrCommentOptions {
  githubToken: string;
  label?: string;
}

export interface CommentData {
  totalCoverage: {
    linesHit: number;
    linesFound: number;
    percentage: number;
  };
  changedFilesCoverage: {
    linesHit: number;
    linesFound: number;
    percentage: number;
  };
  coverageDifference: number;
  fileBreakdown: Array<{
    filename: string;
    linesHit: number;
    linesFound: number;
    percentage: number;
  }>;
}

export class PrCommentService {
  private readonly octokit: ReturnType<typeof github.getOctokit>;
  private readonly label?: string;

  constructor(options: PrCommentOptions) {
    this.octokit = github.getOctokit(options.githubToken);
    this.label = options.label;
  }

  private getCommentTitle(): string {
    return this.label
      ? `Coveragemap Action: ${this.label}`
      : "Coveragemap Action";
  }

  static createCommentData(
    analysis: CoverageAnalysis,
    lcovReport: LcovReport,
  ): CommentData {
    const totalCoverage = {
      linesHit: lcovReport.summary.linesHit,
      linesFound: lcovReport.summary.linesFound,
      percentage:
        Math.round(
          (lcovReport.summary.linesHit / lcovReport.summary.linesFound) *
            100 *
            100,
        ) / 100,
    };

    const changedFilesCoverage = {
      linesHit: analysis.summary.overallCoverage.coveredLines,
      linesFound: analysis.summary.overallCoverage.totalLines,
      percentage: analysis.summary.overallCoverage.overallCoveragePercentage,
    };

    const coverageDifference =
      Math.round(
        (changedFilesCoverage.percentage - totalCoverage.percentage) * 100,
      ) / 100;

    const fileBreakdown = analysis.changedFiles
      .filter((file) => file.coverage) // Only include files with coverage data
      .map((file) => ({
        filename: file.path,
        linesHit: file.analysis.coveredLines,
        linesFound: file.analysis.totalLines,
        percentage: file.analysis.overallCoveragePercentage,
      }));

    return {
      totalCoverage,
      changedFilesCoverage,
      coverageDifference,
      fileBreakdown,
    };
  }

  private generateCommentBody(
    data: CommentData,
    gatingResult: GatingResult,
  ): string {
    const title = this.getCommentTitle();
    const thresholdEmoji = gatingResult.meetsThreshold ? "‚úÖ" : "‚ùå";
    const diffEmoji = data.coverageDifference >= 0 ? "üìà" : "üìâ";
    const diffSign = data.coverageDifference >= 0 ? "+" : "";

    const thresholdDisplay =
      gatingResult.mode === "baseline"
        ? `‚â• Project Avg (${gatingResult.overallProjectCoveragePercentage}%)`
        : `${gatingResult.threshold}%`;

    let markdown = `## ${title}\n\n`;

    // Summary table
    markdown += `| Metric | Coverage | Lines |\n`;
    markdown += `|--------|----------|-------|\n`;
    markdown += `| **Total Coverage** | ${data.totalCoverage.percentage}% | ${data.totalCoverage.linesHit}/${data.totalCoverage.linesFound} |\n`;
    markdown += `| **Changed Files** | ${data.changedFilesCoverage.percentage}% | ${data.changedFilesCoverage.linesHit}/${data.changedFilesCoverage.linesFound} |\n`;
    markdown += `| **Difference** | ${diffEmoji} ${diffSign}${data.coverageDifference}% | - |\n`;
    markdown += `| **Threshold** | ${thresholdEmoji} ${thresholdDisplay} | - |\n\n`;

    // File breakdown if there are any files with coverage data
    if (data.fileBreakdown.length > 0) {
      markdown += `### Changed Files Coverage\n\n`;
      markdown += `| File | Coverage | Lines |\n`;
      markdown += `|------|----------|-------|\n`;

      for (const file of data.fileBreakdown) {
        const fileThresholdMet =
          gatingResult.mode === "baseline"
            ? file.percentage >= gatingResult.overallProjectCoveragePercentage!
            : file.percentage >= gatingResult.threshold;
        const fileEmoji = fileThresholdMet ? "‚úÖ" : "‚ùå";
        markdown += `| ${fileEmoji} \`${file.filename}\` | ${file.percentage}% | ${file.linesHit}/${file.linesFound} |\n`;
      }
      markdown += `\n`;
    }

    // Footer
    markdown += `---\n`;
    markdown += `*Coverage report generated by [Coveragemap Action](https://github.com/maxbirkner/coveragemap)*`;

    return markdown;
  }

  private async findExistingComment(): Promise<number | null> {
    const { context } = github;

    if (!context.payload.pull_request) {
      throw new Error("This action can only be run on pull requests");
    }

    const comments = await this.octokit.rest.issues.listComments({
      owner: context.repo.owner,
      repo: context.repo.repo,
      issue_number: context.payload.pull_request.number,
    });

    const commentTitle = this.getCommentTitle();

    for (const comment of comments.data) {
      if (comment.body?.includes(`## ${commentTitle}`)) {
        return comment.id;
      }
    }

    return null;
  }

  async postComment(
    analysis: CoverageAnalysis,
    lcovReport: LcovReport,
    gatingResult: GatingResult,
  ): Promise<void> {
    const { context } = github;

    if (!context.payload.pull_request) {
      throw new Error("This action can only be run on pull requests");
    }

    const data = PrCommentService.createCommentData(analysis, lcovReport);
    const body = this.generateCommentBody(data, gatingResult);

    try {
      const existingCommentId = await this.findExistingComment();

      if (existingCommentId) {
        // Update existing comment
        await this.octokit.rest.issues.updateComment({
          owner: context.repo.owner,
          repo: context.repo.repo,
          comment_id: existingCommentId,
          body,
        });

        core.info(`‚úÖ Updated existing PR comment (ID: ${existingCommentId})`);
      } else {
        // Create new comment
        const response = await this.octokit.rest.issues.createComment({
          owner: context.repo.owner,
          repo: context.repo.repo,
          issue_number: context.payload.pull_request.number,
          body,
        });

        core.info(`‚úÖ Created new PR comment (ID: ${response.data.id})`);
      }
    } catch (error) {
      throw new Error(
        `Failed to post PR comment: ${
          error instanceof Error ? error.message : String(error)
        }`,
      );
    }
  }
}
